{
  "modules": {
    "Product Management": {
      "modules": [
        "backend",
        "frontend",
        "database"
      ],
      "file_structure": {
        "backend/modules/product/": "Product management module files",
        "backend/modules/product/controllers/": "Product controllers",
        "backend/modules/product/models/": "Product models",
        "backend/modules/product/routes/": "Product routes",
        "backend/config/": "Configuration files",
        "frontend/src/components/Product/": "React components for product display and management",
        "database/migrations/": "Database migration files for product schema"
      },
      "dependencies": [
        "express",
        "mongoose",
        "jsonwebtoken",
        "bcryptjs",
        "dotenv",
        "cors",
        "pg",
        "sequelize"
      ],
      "code_files": {
        "backend/modules/product/controllers/product.controller.js": "const Product = require('../models/product.model');\n\n// Create a new product\nexports.create = async (req, res) => {\n  try {\n    const product = new Product(req.body);\n    const savedProduct = await product.save();\n    res.status(201).send(savedProduct);\n  } catch (error) {\n    res.status(500).send({ message: error.message || 'Some error occurred while creating the Product.' });\n  }\n};\n\n// Retrieve all products\nexports.findAll = async (req, res) => {\n  try {\n    const products = await Product.find();\n    res.send(products);\n  } catch (error) {\n    res.status(500).send({ message: error.message || 'Some error occurred while retrieving products.' });\n  }\n};\n\n// Find a single product with an id\nexports.findOne = async (req, res) => {\n  try {\n    const product = await Product.findById(req.params.id);\n    if (!product) {\n      return res.status(404).send({ message: 'Product not found with id ' + req.params.id });\n    }\n    res.send(product);\n  } catch (error) {\n    if (error.kind === 'ObjectId') {\n      return res.status(404).send({ message: 'Product not found with id ' + req.params.id });\n    }\n    res.status(500).send({ message: 'Error retrieving product with id ' + req.params.id });\n  }\n};\n\n// Update a product identified by the id in the request\nexports.update = async (req, res) => {\n  try {\n    const product = await Product.findByIdAndUpdate(req.params.id, req.body, { new: true });\n    if (!product) {\n      return res.status(404).send({ message: 'Product not found with id ' + req.params.id });\n    }\n    res.send(product);\n  } catch (error) {\n    if (error.kind === 'ObjectId') {\n      return res.status(404).send({ message: 'Product not found with id ' + req.params.id });\n    }\n    res.status(500).send({ message: 'Error updating product with id ' + req.params.id });\n  }\n};\n\n// Delete a product with the specified id in the request\nexports.delete = async (req, res) => {\n  try {\n    const product = await Product.findByIdAndRemove(req.params.id);\n    if (!product) {\n      return res.status(404).send({ message: 'Product not found with id ' + req.params.id });\n    }\n    res.send({ message: 'Product deleted successfully!' });\n  } catch (error) {\n    if (error.kind === 'ObjectId' || error.name === 'NotFound') {\n      return res.status(404).send({ message: 'Product not found with id ' + req.params.id });\n    }\n    res.status(500).send({ message: 'Could not delete product with id ' + req.params.id });\n  }\n};",
        "backend/modules/product/models/product.model.js": "const mongoose = require('mongoose');\n\nconst ProductSchema = mongoose.Schema({\n  name: {\n    type: String,\n    required: true\n  },\n  description: {\n    type: String,\n    required: true\n  },\n  category_id: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'Category',\n    required: true\n  },\n  price: {\n    type: Number,\n    required: true\n  },\n  image_url: {\n    type: String\n  }\n}, {\n  timestamps: true\n});\n\nmodule.exports = mongoose.model('Product', ProductSchema);",
        "backend/modules/product/routes/product.routes.js": "const express = require('express');\nconst router = express.Router();\nconst products = require('../controllers/product.controller');\n\n// Create a new Product\nrouter.post('/', products.create);\n\n// Retrieve all Products\nrouter.get('/', products.findAll);\n\n// Retrieve a single Product with productId\nrouter.get('/:id', products.findOne);\n\n// Update a Product with productId\nrouter.put('/:id', products.update);\n\n// Delete a Product with productId\nrouter.delete('/:id', products.delete);\n\nmodule.exports = router;",
        "backend/config/db.config.js": "module.exports = {\n    url: process.env.DB_URL || 'mongodb://localhost:27017/ecommerce'\n};",
        "frontend/src/components/Product/ProductList.js": "import React, { useState, useEffect } from 'react';\n\nconst ProductList = () => {\n  const [products, setProducts] = useState([]);\n\n  useEffect(() => {\n    // Fetch products from API\n    const fetchProducts = async () => {\n      try {\n        const response = await fetch('/api/products'); // Replace with your API endpoint\n        const data = await response.json();\n        setProducts(data);\n      } catch (error) {\n        console.error('Error fetching products:', error);\n      }\n    };\n\n    fetchProducts();\n  }, []);\n\n  return (\n    <div>\n      <h2>Product List</h2>\n      <ul>\n        {products.map(product => (\n          <li key={product.id}>{product.name} - ${product.price}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default ProductList;",
        "database/migrations/20240101000001-create-products.js": "'use strict';\nmodule.exports = {\n  up: async (queryInterface, Sequelize) => {\n    await queryInterface.createTable('Products', {\n      id: {\n        allowNull: false,\n        autoIncrement: true,\n        primaryKey: true,\n        type: Sequelize.INTEGER\n      },\n      name: {\n        type: Sequelize.STRING,\n        allowNull: false\n      },\n      description: {\n        type: Sequelize.TEXT,\n        allowNull: false\n      },\n      category_id: {\n        type: Sequelize.INTEGER,\n        allowNull: false,\n        references: {\n          model: 'Categories',\n          key: 'id'\n        },\n        onUpdate: 'CASCADE',\n        onDelete: 'CASCADE'\n      },\n      price: {\n        type: Sequelize.DECIMAL(10, 2),\n        allowNull: false\n      },\n      image_url: {\n        type: Sequelize.STRING\n      },\n      createdAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      },\n      updatedAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      }\n    });\n  },\n  down: async (queryInterface, Sequelize) => {\n    await queryInterface.dropTable('Products');\n  }\n};"
      }
    },
    "Category Management": {
      "modules": [
        "backend",
        "frontend",
        "database"
      ],
      "file_structure": {
        "backend/modules/category/": "Category management module files",
        "backend/modules/category/controllers/": "Category controllers",
        "backend/modules/category/models/": "Category models",
        "backend/modules/category/routes/": "Category routes",
        "backend/config/": "Configuration files",
        "frontend/src/components/category/": "Category components",
        "database/migrations/": "Category migrations"
      },
      "dependencies": [
        "express",
        "mongoose",
        "dotenv",
        "cors",
        "jsonwebtoken",
        "bcryptjs",
        "pg",
        "pg-hstore",
        "sequelize"
      ],
      "code_files": {
        "backend/modules/category/models/category.model.js": "const { Sequelize, DataTypes } = require('sequelize');\nconst sequelize = require('../../../config/database');\n\nconst Category = sequelize.define('Category', {\n  id: {\n    type: DataTypes.INTEGER,\n    primaryKey: true,\n    autoIncrement: true,\n  },\n  name: {\n    type: DataTypes.STRING,\n    allowNull: false,\n  },\n  description: {\n    type: DataTypes.STRING,\n  },\n  image_url: {\n    type: DataTypes.STRING,\n  },\n}, {\n  tableName: 'Categories',\n  timestamps: true,\n});\n\nmodule.exports = Category;",
        "backend/modules/category/controllers/category.controller.js": "const Category = require('../models/category.model');\n\n// Create a new category\nexports.create = async (req, res) => {\n  try {\n    const category = await Category.create(req.body);\n    res.status(201).json(category);\n  } catch (err) {\n    res.status(500).json({ message: err.message });\n  }\n};\n\n// Get all categories\nexports.findAll = async (req, res) => {\n  try {\n    const categories = await Category.findAll();\n    res.status(200).json(categories);\n  } catch (err) {\n    res.status(500).json({ message: err.message });\n  }\n};\n\n// Get a category by ID\nexports.findOne = async (req, res) => {\n  try {\n    const category = await Category.findByPk(req.params.id);\n    if (category) {\n      res.status(200).json(category);\n    } else {\n      res.status(404).json({ message: 'Category not found' });\n    }\n  } catch (err) {\n    res.status(500).json({ message: err.message });\n  }\n};\n\n// Update a category by ID\nexports.update = async (req, res) => {\n  try {\n    const category = await Category.update(req.body, {\n      where: { id: req.params.id },\n    });\n    if (category[0] > 0) {\n      res.status(200).json({ message: 'Category updated successfully' });\n    } else {\n      res.status(404).json({ message: 'Category not found' });\n    }\n  } catch (err) {\n    res.status(500).json({ message: err.message });\n  }\n};\n\n// Delete a category by ID\nexports.delete = async (req, res) => {\n  try {\n    const category = await Category.destroy({\n      where: { id: req.params.id },\n    });\n    if (category) {\n      res.status(200).json({ message: 'Category deleted successfully' });\n    } else {\n      res.status(404).json({ message: 'Category not found' });\n    }\n  } catch (err) {\n    res.status(500).json({ message: err.message });\n  }\n};",
        "backend/modules/category/routes/category.routes.js": "const express = require('express');\nconst router = express.Router();\nconst categoryController = require('../controllers/category.controller');\n\n// Create a new category\nrouter.post('/', categoryController.create);\n\n// Get all categories\nrouter.get('/', categoryController.findAll);\n\n// Get a category by ID\nrouter.get('/:id', categoryController.findOne);\n\n// Update a category by ID\nrouter.put('/:id', categoryController.update);\n\n// Delete a category by ID\nrouter.delete('/:id', categoryController.delete);\n\nmodule.exports = router;",
        "backend/config/database.js": "const { Sequelize } = require('sequelize');\nrequire('dotenv').config();\n\nconst sequelize = new Sequelize(process.env.DB_NAME, process.env.DB_USER, process.env.DB_PASS, {\n  host: process.env.DB_HOST,\n  dialect: 'postgres',\n  port: process.env.DB_PORT,\n  dialectOptions: {\n    ssl: process.env.DB_SSL === 'true' ? {require: true, rejectUnauthorized: false} : false\n  },\n  logging: false\n});\n\nconst testDatabaseConnection = async () => {\n  try {\n    await sequelize.authenticate();\n    console.log('Connection has been established successfully.');\n    await sequelize.sync({ alter: false });\n    console.log('Database synchronized.');\n  } catch (error) {\n    console.error('Unable to connect to the database:', error);\n  }\n};\n\ntestDatabaseConnection();\n\nmodule.exports = sequelize;",
        "frontend/src/components/category/CategoryList.js": "import React, { useState, useEffect } from 'react';\n\nconst CategoryList = () => {\n  const [categories, setCategories] = useState([]);\n\n  useEffect(() => {\n    const fetchCategories = async () => {\n      try {\n        const response = await fetch('/api/categories'); // Assuming your backend route\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        setCategories(data);\n      } catch (error) {\n        console.error('Could not fetch categories:', error);\n      }\n    };\n\n    fetchCategories();\n  }, []);\n\n  return (\n    <div>\n      <h2>Categories</h2>\n      <ul>\n        {categories.map(category => (\n          <li key={category.id}>{category.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default CategoryList;",
        "database/migrations/20250605140000-create-categories.js": "'use strict';\n\nmodule.exports = {\n  up: async (queryInterface, Sequelize) => {\n    await queryInterface.createTable('Categories', {\n      id: {\n        allowNull: false,\n        autoIncrement: true,\n        primaryKey: true,\n        type: Sequelize.INTEGER\n      },\n      name: {\n        type: Sequelize.STRING,\n        allowNull: false\n      },\n      description: {\n        type: Sequelize.STRING\n      },\n      image_url: {\n        type: Sequelize.STRING\n      },\n      createdAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      },\n      updatedAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      }\n    });\n  },\n\n  down: async (queryInterface, Sequelize) => {\n    await queryInterface.dropTable('Categories');\n  }\n};"
      }
    },
    "User Authentication": {
      "modules": [
        "backend",
        "frontend",
        "database",
        "user_authentication"
      ],
      "file_structure": {
        "backend/modules/user_authentication/": "User authentication module files",
        "backend/modules/user_authentication/controllers/": "Controllers for handling user authentication requests",
        "backend/modules/user_authentication/models/": "Data models for user authentication",
        "backend/modules/user_authentication/routes/": "API routes for user authentication",
        "backend/modules/user_authentication/services/": "Business logic for user authentication",
        "backend/config/": "Configuration files",
        "frontend/src/components/auth/": "React components for authentication",
        "frontend/src/services/": "API services for authentication"
      },
      "dependencies": [
        "bcrypt",
        "jsonwebtoken",
        "express-validator",
        "passport",
        "passport-jwt",
        "axios"
      ],
      "code_files": {
        "backend/modules/user_authentication/controllers/authController.js": "const bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\nconst { validationResult } = require('express-validator');\nconst User = require('../models/User');\nconst config = require('../../../config/config');\n\nexports.register = async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  const { username, email, password } = req.body;\n\n  try {\n    let user = await User.findOne({ email });\n    if (user) {\n      return res.status(400).json({ msg: 'User already exists' });\n    }\n\n    user = new User({\n      username,\n      email,\n      password,\n    });\n\n    const salt = await bcrypt.genSalt(10);\n    user.password = await bcrypt.hash(password, salt);\n\n    await user.save();\n\n    const payload = {\n      user: {\n        id: user.id,\n      },\n    };\n\n    jwt.sign(\n      payload,\n      config.jwtSecret,\n      { expiresIn: 3600 },\n      (err, token) => {\n        if (err) throw err;\n        res.json({ token });\n      }\n    );\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).send('Server error');\n  }\n};\n\nexports.login = async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n\n  const { email, password } = req.body;\n\n  try {\n    let user = await User.findOne({ email });\n\n    if (!user) {\n      return res.status(400).json({ msg: 'Invalid Credentials' });\n    }\n\n    const isMatch = await bcrypt.compare(password, user.password);\n\n    if (!isMatch) {\n      return res.status(400).json({ msg: 'Invalid Credentials' });\n    }\n\n    const payload = {\n      user: {\n        id: user.id,\n      },\n    };\n\n    jwt.sign(\n      payload,\n      config.jwtSecret,\n      { expiresIn: 3600 },\n      (err, token) => {\n        if (err) throw err;\n        res.json({ token });\n      }\n    );\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).send('Server error');\n  }\n};\n\nexports.getLoggedInUser = async (req, res) => {\n  try {\n    const user = await User.findById(req.user.id).select('-password');\n    res.json(user);\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).send('Server Error');\n  }\n};",
        "backend/modules/user_authentication/models/User.js": "const mongoose = require('mongoose');\n\nconst UserSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: true,\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n  },\n  password: {\n    type: String,\n    required: true,\n  },\n  date: {\n    type: Date,\n    default: Date.now,\n  },\n});\n\nmodule.exports = mongoose.model('user', UserSchema);",
        "backend/modules/user_authentication/routes/auth.js": "const express = require('express');\nconst router = express.Router();\nconst { check } = require('express-validator');\nconst authController = require('../controllers/authController');\nconst auth = require('../../../middleware/auth');\n\nrouter.post(\n  '/register',\n  [\n    check('username', 'Username is required').not().isEmpty(),\n    check('email', 'Please include a valid email').isEmail(),\n    check(\n      'password',\n      'Please enter a password with 6 or more characters'\n    ).isLength({ min: 6 }),\n  ],\n  authController.register\n);\n\nrouter.post(\n  '/login',\n  [\n    check('email', 'Please include a valid email').isEmail(),\n    check('password', 'Password is required').exists(),\n  ],\n  authController.login\n);\n\nrouter.get('/', auth, authController.getLoggedInUser);\n\nmodule.exports = router;",
        "backend/config/config.js": "module.exports = {\n    port: process.env.PORT || 5000,\n    dbURI: process.env.MONGODB_URI || 'mongodb://localhost:27017/ecommerce',\n    jwtSecret: process.env.JWT_SECRET || 'secret',\n  };",
        "backend/middleware/auth.js": "const jwt = require('jsonwebtoken');\nconst config = require('../config/config');\n\nmodule.exports = function (req, res, next) {\n  // Get token from header\n  const token = req.header('x-auth-token');\n\n  // Check if not token\n  if (!token) {\n    return res.status(401).json({ msg: 'No token, authorization denied' });\n  }\n\n  // Verify token\n  try {\n    const decoded = jwt.verify(token, config.jwtSecret);\n\n    req.user = decoded.user;\n    next();\n  } catch (err) {\n    res.status(401).json({ msg: 'Token is not valid' });\n  }\n};",
        "frontend/src/components/auth/Login.js": "import React, { useState } from 'react';\nimport axios from 'axios';\n\nconst Login = () => {\n  const [formData, setFormData] = useState({\n    email: '',\n    password: '',\n  });\n\n  const { email, password } = formData;\n\n  const onChange = (e) =>\n    setFormData({ ...formData, [e.target.name]: e.target.value });\n\n  const onSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      const config = {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      };\n\n      const body = JSON.stringify({ email, password });\n\n      const res = await axios.post('/api/auth/login', body, config);\n      console.log(res.data);\n      // Store token and redirect\n    } catch (err) {\n      console.error(err.response.data);\n    }\n  };\n\n  return (\n    <form onSubmit={(e) => onSubmit(e)}>\n      <div>\n        <label>Email</label>\n        <input\n          type='email'\n          name='email'\n          value={email}\n          onChange={(e) => onChange(e)}\n          required\n        />\n      </div>\n      <div>\n        <label>Password</label>\n        <input\n          type='password'\n          name='password'\n          value={password}\n          onChange={(e) => onChange(e)}\n          required\n        />\n      </div>\n      <button type='submit'>Login</button>\n    </form>\n  );\n};\n\nexport default Login;",
        "frontend/src/components/auth/Register.js": "import React, { useState } from 'react';\nimport axios from 'axios';\n\nconst Register = () => {\n  const [formData, setFormData] = useState({\n    username: '',\n    email: '',\n    password: '',\n    password2: '',\n  });\n\n  const { username, email, password, password2 } = formData;\n\n  const onChange = (e) =>\n    setFormData({ ...formData, [e.target.name]: e.target.value });\n\n  const onSubmit = async (e) => {\n    e.preventDefault();\n    if (password !== password2) {\n      console.log('Passwords do not match');\n    } else {\n      try {\n        const config = {\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        };\n\n        const body = JSON.stringify({ username, email, password });\n\n        const res = await axios.post('/api/auth/register', body, config);\n        console.log(res.data);\n        // Store token and redirect\n      } catch (err) {\n        console.error(err.response.data);\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={(e) => onSubmit(e)}>\n      <div>\n        <label>Username</label>\n        <input\n          type='text'\n          name='username'\n          value={username}\n          onChange={(e) => onChange(e)}\n          required\n        />\n      </div>\n      <div>\n        <label>Email</label>\n        <input\n          type='email'\n          name='email'\n          value={email}\n          onChange={(e) => onChange(e)}\n          required\n        />\n      </div>\n      <div>\n        <label>Password</label>\n        <input\n          type='password'\n          name='password'\n          value={password}\n          onChange={(e) => onChange(e)}\n          required\n        />\n      </div>\n      <div>\n        <label>Confirm Password</label>\n        <input\n          type='password'\n          name='password2'\n          value={password2}\n          onChange={(e) => onChange(e)}\n          required\n        />\n      </div>\n      <button type='submit'>Register</button>\n    </form>\n  );\n};\n\nexport default Register;",
        "frontend/src/services/authService.js": "import axios from 'axios';\n\nconst API_URL = '/api/auth';\n\nconst register = (username, email, password) => {\n  return axios.post(API_URL + '/register', {\n    username,\n    email,\n    password,\n  });\n};\n\nconst login = (email, password) => {\n  return axios\n    .post(API_URL + '/login', {\n      email,\n      password,\n    })\n    .then((response) => {\n      if (response.data.token) {\n        localStorage.setItem('user', JSON.stringify(response.data));\n      }\n\n      return response.data;\n    });\n};\n\nconst logout = () => {\n  localStorage.removeItem('user');\n};\n\nconst getCurrentUser = () => {\n  return JSON.parse(localStorage.getItem('user'));\n};\n\nexport default {\n  register,\n  login,\n  logout,\n  getCurrentUser,\n};",
        "package.json": "{\n  \"name\": \"ecommerce_platform\",\n  \"version\": \"1.0.0\",\n  \"description\": \"E-commerce platform with Node.js, Express.js, React, and PostgreSQL\",\n  \"main\": \"src/main.js\",\n  \"scripts\": {\n    \"start\": \"node src/main.js\",\n    \"dev\": \"nodemon src/main.js\"\n  },\n  \"dependencies\": {\n    \"bcrypt\": \"^5.0.1\",\n    \"express\": \"^4.17.1\",\n    \"express-validator\": \"^6.12.0\",\n    \"jsonwebtoken\": \"^8.5.1\",\n    \"mongoose\": \"^6.0.5\",\n    \"passport\": \"^0.6.0\",\n    \"passport-jwt\": \"^4.0.0\",\n    \"axios\": \"^0.21.4\",\n    \"cors\": \"^2.8.5\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.12\"\n  }\n}"
      }
    },
    "Order Management": {
      "modules": [
        "backend",
        "frontend",
        "database",
        "order_management"
      ],
      "file_structure": {
        "backend/order_management/": "Order management module files",
        "backend/order_management/controllers/": "Order controllers",
        "backend/order_management/models/": "Order models",
        "backend/order_management/routes/": "Order routes",
        "database/migrations/": "Order management migrations"
      },
      "dependencies": [
        "express",
        "mongoose",
        "jsonwebtoken",
        "bcryptjs",
        "dotenv",
        "cors",
        "pg",
        "pg-hstore",
        "sequelize"
      ],
      "code_files": {
        "backend/order_management/models/order.js": "const { Sequelize, DataTypes } = require('sequelize');\nconst sequelize = require('../../../database/config/database');\n\nconst Order = sequelize.define('Order', {\n  id: {\n    type: DataTypes.INTEGER,\n    primaryKey: true,\n    autoIncrement: true,\n  },\n  user_id: {\n    type: DataTypes.INTEGER,\n    allowNull: false,\n  },\n  order_date: {\n    type: DataTypes.DATE,\n    allowNull: false,\n  },\n  total_amount: {\n    type: DataTypes.DECIMAL(10, 2),\n    allowNull: false,\n  },\n  status: {\n    type: DataTypes.STRING,\n    allowNull: false,\n  },\n});\n\nmodule.exports = Order;",
        "backend/order_management/models/orderItem.js": "const { Sequelize, DataTypes } = require('sequelize');\nconst sequelize = require('../../../database/config/database');\nconst Order = require('./order');\nconst Product = require('../../product_management/models/product');\n\nconst OrderItem = sequelize.define('OrderItem', {\n  id: {\n    type: DataTypes.INTEGER,\n    primaryKey: true,\n    autoIncrement: true,\n  },\n  order_id: {\n    type: DataTypes.INTEGER,\n    allowNull: false,\n    references: {\n      model: Order,\n      key: 'id',\n    },\n  },\n  product_id: {\n    type: DataTypes.INTEGER,\n    allowNull: false,\n    references: {\n      model: Product,\n      key: 'id',\n    },\n  },\n  quantity: {\n    type: DataTypes.INTEGER,\n    allowNull: false,\n  },\n  price: {\n    type: DataTypes.DECIMAL(10, 2),\n    allowNull: false,\n  },\n});\n\nOrderItem.belongsTo(Order, { foreignKey: 'order_id' });\n\nmodule.exports = OrderItem;",
        "backend/order_management/controllers/orderController.js": "const Order = require('../models/order');\nconst OrderItem = require('../models/orderItem');\n\nexports.getAllOrders = async (req, res) => {\n  try {\n    const orders = await Order.findAll();\n    res.status(200).json(orders);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Error fetching orders' });\n  }\n};\n\nexports.getOrderById = async (req, res) => {\n  const { id } = req.params;\n  try {\n    const order = await Order.findByPk(id, {\n      include: [OrderItem],\n    });\n    if (!order) {\n      return res.status(404).json({ message: 'Order not found' });\n    }\n    res.status(200).json(order);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Error fetching order' });\n  }\n};\n\nexports.createOrder = async (req, res) => {\n  try {\n    const { user_id, order_date, total_amount, status, orderItems } = req.body;\n\n    const order = await Order.create({\n      user_id,\n      order_date,\n      total_amount,\n      status,\n    });\n\n    if (orderItems && orderItems.length > 0) {\n      await Promise.all(\n        orderItems.map(async (item) => {\n          await OrderItem.create({\n            order_id: order.id,\n            product_id: item.product_id,\n            quantity: item.quantity,\n            price: item.price,\n          });\n        })\n      );\n    }\n\n    res.status(201).json(order);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Error creating order' });\n  }\n};\n\nexports.updateOrder = async (req, res) => {\n  const { id } = req.params;\n  try {\n    const [updated] = await Order.update(req.body, {\n      where: { id: id },\n    });\n    if (updated) {\n      const updatedOrder = await Order.findByPk(id);\n      return res.status(200).json(updatedOrder);\n    }\n    return res.status(404).json({ message: 'Order not found' });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Error updating order' });\n  }\n};\n\nexports.deleteOrder = async (req, res) => {\n  const { id } = req.params;\n  try {\n    const deleted = await Order.destroy({\n      where: { id: id },\n    });\n    if (deleted) {\n      return res.status(204).send();\n    }\n    return res.status(404).json({ message: 'Order not found' });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Error deleting order' });\n  }\n};",
        "backend/order_management/routes/orderRoutes.js": "const express = require('express');\nconst orderController = require('../controllers/orderController');\nconst router = express.Router();\n\nrouter.get('/', orderController.getAllOrders);\nrouter.get('/:id', orderController.getOrderById);\nrouter.post('/', orderController.createOrder);\nrouter.put('/:id', orderController.updateOrder);\nrouter.delete('/:id', orderController.deleteOrder);\n\nmodule.exports = router;",
        "src/app.js": "const express = require('express');\nconst cors = require('cors');\nconst productRoutes = require('./product_management/routes/productRoutes');\nconst categoryRoutes = require('./category_management/routes/categoryRoutes');\nconst userRoutes = require('./user_authentication/routes/userRoutes');\nconst orderRoutes = require('./order_management/routes/orderRoutes');\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\n\napp.use('/products', productRoutes);\napp.use('/categories', categoryRoutes);\napp.use('/users', userRoutes);\napp.use('/orders', orderRoutes);\n\nmodule.exports = app;",
        "database/config/database.js": "const { Sequelize } = require('sequelize');\nrequire('dotenv').config();\n\nconst sequelize = new Sequelize(process.env.DB_NAME, process.env.DB_USER, process.env.DB_PASS, {\n  host: process.env.DB_HOST,\n  dialect: 'postgres',\n  port: process.env.DB_PORT,\n  dialectOptions: {\n    ssl: {\n      require: true, // This will vary depending on your setup\n      rejectUnauthorized: false, // You might need this\n    },\n  },\n});\n\nconst testConnection = async () => {\n  try {\n    await sequelize.authenticate();\n    console.log('Connection has been established successfully.');\n  } catch (error) {\n    console.error('Unable to connect to the database:', error);\n  }\n};\n\ntestConnection();\n\nmodule.exports = sequelize;"
      }
    },
    "Payment Integration": {
      "modules": [
        "backend",
        "frontend",
        "database",
        "payment"
      ],
      "file_structure": {
        "backend/payment/": "Payment integration module files",
        "backend/payment/config/": "Configuration files for payment gateways",
        "backend/payment/controllers/": "API controllers for payment processing",
        "backend/payment/models/": "Data models for payment transactions",
        "backend/payment/routes/": "API routes for payment integration",
        "backend/payment/services/": "Payment processing services (VNPay, Momo)",
        "frontend/src/components/payment/": "React components for payment integration",
        "frontend/src/services/payment.js": "API service for payment integration",
        "database/migrations/": "Database migration files for payment-related tables"
      },
      "dependencies": [
        "express",
        "axios",
        "jsonwebtoken",
        "pg",
        "dotenv",
        "cors",
        "morgan",
        "vnpay",
        "momo-payment"
      ],
      "code_files": {
        "backend/payment/config/vnpay.config.js": "module.exports = {\n  tmnCode: process.env.VNP_TMN_CODE || 'YOUR_VNPAY_TMN_CODE',\n  secretKey: process.env.VNP_SECRET_KEY || 'YOUR_VNPAY_SECRET_KEY',\n  returnUrl: process.env.VNP_RETURN_URL || 'http://localhost:3000/payment/vnpay_return',\n  apiUrl: process.env.VNP_API_URL || 'http://sandbox.vnpayment.vn/paymentv2/vpcpay.html',\n  ipnUrl: process.env.VNP_IPN_URL || 'http://localhost:3000/payment/vnpay_ipn',\n  version: '2.1.0',\n  command: 'pay',\n  currCode: 'VND',\n  locale: 'vn'\n};\n",
        "backend/payment/config/momo.config.js": "module.exports = {\n  partnerCode: process.env.MOMO_PARTNER_CODE || 'YOUR_MOMO_PARTNER_CODE',\n  accessKey: process.env.MOMO_ACCESS_KEY || 'YOUR_MOMO_ACCESS_KEY',\n  secretKey: process.env.MOMO_SECRET_KEY || 'YOUR_MOMO_SECRET_KEY',\n  returnUrl: process.env.MOMO_RETURN_URL || 'http://localhost:3000/payment/momo_return',\n  notifyUrl: process.env.MOMO_NOTIFY_URL || 'http://localhost:3000/payment/momo_ipn',\n  endpoint: process.env.MOMO_ENDPOINT || 'https://test-payment.momo.vn/gw_payment/transactionProcessor'\n};\n",
        "backend/payment/controllers/payment.controller.js": "const vnpayService = require('../services/vnpay.service');\nconst momoService = require('../services/momo.service');\nconst Payment = require('../models/payment.model');\n\nexports.createPaymentVNPay = async (req, res) => {\n  try {\n    const paymentData = req.body;\n    const url = await vnpayService.createPaymentUrl(paymentData);\n    res.json({ url });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Failed to create VNPay payment URL' });\n  }\n};\n\nexports.vnpayReturn = async (req, res) => {\n  try {\n    const result = await vnpayService.vnpayReturn(req.query);\n    // Save payment information to the database\n    const newPayment = new Payment({\n      transactionId: req.query.vnp_TransactionNo,\n      paymentMethod: 'VNPay',\n      amount: req.query.vnp_Amount / 100,\n      status: result.success ? 'success' : 'failed',\n      details: req.query\n    });\n    await newPayment.save();\n\n    res.json(result);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'VNPay return processing failed' });\n  }\n};\n\nexports.vnpayIpn = async (req, res) => {\n  try {\n    const result = await vnpayService.vnpayIpn(req.query);\n    res.json(result);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'VNPay IPN processing failed' });\n  }\n};\n\nexports.createPaymentMomo = async (req, res) => {\n  try {\n    const paymentData = req.body;\n    const result = await momoService.createPayment(paymentData);\n    res.json(result);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Failed to create Momo payment URL' });\n  }\n};\n\nexports.momoReturn = async (req, res) => {\n  try {\n    // Handle Momo return\n    res.json({ message: 'Momo return received', data: req.query });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Momo return processing failed' });\n  }\n};\n\nexports.momoIpn = async (req, res) => {\n  try {\n    // Handle Momo IPN\n    res.json({ message: 'Momo IPN received', data: req.body });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Momo IPN processing failed' });\n  }\n};\n",
        "backend/payment/models/payment.model.js": "const { Pool } = require('pg');\n\nconst pool = new Pool({\n  user: process.env.DB_USER || 'postgres',\n  host: process.env.DB_HOST || 'localhost',\n  database: process.env.DB_NAME || 'ecommerce',\n  password: process.env.DB_PASSWORD || 'password',\n  port: process.env.DB_PORT || 5432\n});\n\nclass Payment {\n  constructor(payment) {\n    this.transactionId = payment.transactionId;\n    this.paymentMethod = payment.paymentMethod;\n    this.amount = payment.amount;\n    this.status = payment.status;\n    this.details = payment.details;\n  }\n\n  async save() {\n    const query = {\n      text: 'INSERT INTO Payments(transaction_id, payment_method, amount, status, details) VALUES($1, $2, $3, $4, $5)',\n      values: [this.transactionId, this.paymentMethod, this.amount, this.status, JSON.stringify(this.details)]\n    };\n\n    try {\n      await pool.query(query);\n      console.log('Payment saved successfully');\n    } catch (err) {\n      console.error(err);\n      throw err;\n    }\n  }\n}\n\nmodule.exports = Payment;\n",
        "backend/payment/routes/payment.routes.js": "const express = require('express');\nconst paymentController = require('../controllers/payment.controller');\n\nconst router = express.Router();\n\nrouter.post('/vnpay/create_payment', paymentController.createPaymentVNPay);\nrouter.get('/vnpay_return', paymentController.vnpayReturn);\nrouter.get('/vnpay_ipn', paymentController.vnpayIpn);\n\nrouter.post('/momo/create_payment', paymentController.createPaymentMomo);\nrouter.get('/momo_return', paymentController.momoReturn);\nrouter.post('/momo_ipn', paymentController.momoIpn);\n\nmodule.exports = router;\n",
        "backend/payment/services/vnpay.service.js": "const querystring = require('qs');\nconst crypto = require('crypto');\nconst vnpayConfig = require('../config/vnpay.config');\n\nexports.createPaymentUrl = async (paymentData) => {\n  const createDate = new Date();\n  const ipAddr = paymentData.ipAddr || '127.0.0.1';\n\n  const tmnCode = vnpayConfig.tmnCode;\n  const secretKey = vnpayConfig.secretKey;\n  let vnpUrl = vnpayConfig.apiUrl;\n  const returnUrl = vnpayConfig.returnUrl;\n\n  const vnp_Params = {};\n  vnp_Params['vnp_Version'] = vnpayConfig.version;\n  vnp_Params['vnp_Command'] = vnpayConfig.command;\n  vnp_Params['vnp_TmnCode'] = tmnCode;\n  vnp_Params['vnp_Locale'] = vnpayConfig.locale;\n  vnp_Params['vnp_CurrCode'] = vnpayConfig.currCode;\n  vnp_Params['vnp_TxnRef'] = paymentData.orderId;\n  vnp_Params['vnp_Amount'] = paymentData.amount * 100;\n  vnp_Params['vnp_ReturnUrl'] = returnUrl;\n  vnp_Params['vnp_IpAddr'] = ipAddr;\n  vnp_Params['vnp_CreateDate'] = formatDate(createDate);\n  vnp_Params['vnp_BankCode'] = paymentData.bankCode || '';\n  vnp_Params['vnp_OrderInfo'] = paymentData.orderInfo || 'Payment for order';\n  vnp_Params['vnp_TransactionType'] = '01'; // Adjust as needed\n\n  const secureHash = generateVnpayHash(vnp_Params, secretKey);\n\n  vnp_Params['vnp_SecureHash'] = secureHash;\n\n  vnpUrl += '?' + querystring.stringify(vnp_Params, { encode: false });\n\n  return vnpUrl;\n};\n\nexports.vnpayReturn = async (vnpayQuery) => {\n  try {\n    const secureHash = vnpayQuery['vnp_SecureHash'];\n    delete vnpayQuery['vnp_SecureHash'];\n    delete vnpayQuery['vnp_SecureHashType'];\n\n    const secretKey = vnpayConfig.secretKey;\n\n    const checkHash = generateVnpayHash(vnpayQuery, secretKey);\n\n    if (secureHash === checkHash) {\n      if (vnpayQuery['vnp_ResponseCode'] === '00') {\n        return { success: true, message: 'Payment successful', data: vnpayQuery };\n      } else {\n        return { success: false, message: 'Payment failed', data: vnpayQuery };\n      }\n    } else {\n      return { success: false, message: 'Invalid signature', data: vnpayQuery };\n    }\n  } catch (error) {\n    console.error(error);\n    return { success: false, message: 'Error processing VNPay return', error: error };\n  }\n};\n\nexports.vnpayIpn = async (vnpayQuery) => {\n  try {\n    const secureHash = vnpayQuery['vnp_SecureHash'];\n    delete vnpayQuery['vnp_SecureHash'];\n    delete vnpayQuery['vnp_SecureHashType'];\n\n    const secretKey = vnpayConfig.secretKey;\n\n    const checkHash = generateVnpayHash(vnpayQuery, secretKey);\n\n    if (secureHash === checkHash) {\n      if (vnpayQuery['vnp_ResponseCode'] === '00') {\n        // Update order status in database\n        return { success: true, message: 'IPN: Payment successful', data: vnpayQuery };\n      } else {\n        return { success: false, message: 'IPN: Payment failed', data: vnpayQuery };\n      }\n    } else {\n      return { success: false, message: 'IPN: Invalid signature', data: vnpayQuery };\n    }\n  } catch (error) {\n    console.error(error);\n    return { success: false, message: 'Error processing VNPay IPN', error: error };\n  }\n};\n\nfunction generateVnpayHash(vnp_Params, secretKey) {\n  const signData = querystring.stringify(vnp_Params, { encode: false });\n  const hmac = crypto.createHmac('sha512', secretKey);\n  const signed = hmac.update(new Buffer(signData, 'utf-8')).digest('hex');\n  return signed;\n}\n\nfunction formatDate(date) {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  const hour = String(date.getHours()).padStart(2, '0');\n  const minute = String(date.getMinutes()).padStart(2, '0');\n  const second = String(date.getSeconds()).padStart(2, '0');\n  return `${year}${month}${day}${hour}${minute}${second}`;\n}\n",
        "backend/payment/services/momo.service.js": "const axios = require('axios');\nconst momoConfig = require('../config/momo.config');\nconst crypto = require('crypto');\n\nexports.createPayment = async (paymentData) => {\n  try {\n    const orderId = paymentData.orderId;\n    const amount = paymentData.amount;\n    const orderInfo = paymentData.orderInfo || 'Payment for order';\n    const returnUrl = momoConfig.returnUrl;\n    const notifyUrl = momoConfig.notifyUrl;\n    const partnerCode = momoConfig.partnerCode;\n    const accessKey = momoConfig.accessKey;\n    const secretKey = momoConfig.secretKey;\n    const endpoint = momoConfig.endpoint;\n\n    const requestId = orderId;\n    const requestType = 'captureWallet';\n    const extraData = paymentData.extraData || '';\nn\n    const rawSignature = `accessKey=${accessKey}&amount=${amount}&extraData=${extraData}&ipnUrl=${notifyUrl}&orderId=${orderId}&orderInfo=${orderInfo}&partnerCode=${partnerCode}&redirectUrl=${returnUrl}&requestId=${requestId}&requestType=${requestType}`;\n\n    const signature = crypto.createHmac('sha256', secretKey)\n      .update(rawSignature)\n      .digest('hex');\n\n    const requestBody = {\n      partnerCode: partnerCode,\n      accessKey: accessKey,\n      requestId: requestId,\n      amount: amount,\n      orderId: orderId,\n      orderInfo: orderInfo,\n      redirectUrl: returnUrl,\n      ipnUrl: notifyUrl,\n      extraData: extraData,\n      requestType: requestType,\n      signature: signature\n    };\n\n    const response = await axios.post(endpoint, requestBody, {\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n\n    return response.data;\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n};\n",
        "frontend/src/components/payment/PaymentForm.js": "import React, { useState } from 'react';\nimport { createPaymentVNPay, createPaymentMomo } from '../../services/payment';\n\nconst PaymentForm = () => {\n  const [amount, setAmount] = useState('');\n  const [orderId, setOrderId] = useState('');\n  const [paymentUrl, setPaymentUrl] = useState('');\n\n  const handleVNPayPayment = async () => {\n    try {\n      const data = await createPaymentVNPay({ amount: parseFloat(amount), orderId: orderId });\n      setPaymentUrl(data.url);\n      window.location.href = data.url;\n    } catch (error) {\n      console.error(error);\n      alert('Failed to create VNPay payment');\n    }\n  };\n\n  const handleMomoPayment = async () => {\n    try {\n      const data = await createPaymentMomo({ amount: parseFloat(amount), orderId: orderId });\n      if (data.payUrl) {\n        setPaymentUrl(data.payUrl);\n        window.location.href = data.payUrl;\n      } else {\n        alert('Failed to create Momo payment: ' + data.message);\n      }\n    } catch (error) {\n      console.error(error);\n      alert('Failed to create Momo payment');\n    }\n  };\n\n  return (\n    <div>\n      <h2>Payment Integration</h2>\n      <div>\n        <label>Amount:</label>\n        <input type=\"number\" value={amount} onChange={(e) => setAmount(e.target.value)} />\n      </div>\n      <div>\n        <label>Order ID:</label>\n        <input type=\"text\" value={orderId} onChange={(e) => setOrderId(e.target.value)} />\n      </div>\n      <button onClick={handleVNPayPayment}>Pay with VNPay</button>\n      <button onClick={handleMomoPayment}>Pay with Momo</button>\n      {paymentUrl && (\n        <div>\n          <a href={paymentUrl} target=\"_blank\" rel=\"noopener noreferrer\">\n            Go to Payment\n          </a>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default PaymentForm;\n",
        "frontend/src/services/payment.js": "import axios from 'axios';\n\nconst API_URL = 'http://localhost:3000/payment'; // Replace with your backend API URL\n\nexport const createPaymentVNPay = async (paymentData) => {\n  try {\n    const response = await axios.post(`${API_URL}/vnpay/create_payment`, paymentData);\n    return response.data;\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n};\n\nexport const createPaymentMomo = async (paymentData) => {\n  try {\n    const response = await axios.post(`${API_URL}/momo/create_payment`, paymentData);\n    return response.data;\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n};\n",
        "database/migrations/20250605140000_create_payments_table.js": "exports.up = function(knex) {\n  return knex.schema.createTable('Payments', (table) => {\n    table.increments('id').primary();\n    table.string('transaction_id').notNullable();\n    table.string('payment_method').notNullable();\n    table.decimal('amount').notNullable();\n    table.string('status').notNullable();\n    table.jsonb('details');\n    table.timestamps(true, true);\n  });\n};\n\nexports.down = function(knex) {\n  return knex.schema.dropTable('Payments');\n};"
      }
    },
    "Shopping Cart": {
      "modules": [
        "backend",
        "frontend",
        "database"
      ],
      "file_structure": {
        "backend/src/shopping_cart/": "Shopping cart module files",
        "backend/src/shopping_cart/controllers/": "Shopping cart controllers",
        "backend/src/shopping_cart/models/": "Shopping cart models",
        "backend/src/shopping_cart/routes/": "Shopping cart routes",
        "frontend/src/components/ShoppingCart/": "React components for shopping cart",
        "database/migrations/": "Database migrations for shopping cart tables"
      },
      "dependencies": [
        "express",
        "mongoose",
        "jsonwebtoken",
        "axios",
        "pg",
        "pg-hstore"
      ],
      "code_files": {
        "backend/src/shopping_cart/models/cart.js": "const mongoose = require('mongoose');\n\nconst cartSchema = new mongoose.Schema({\n  user_id: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  items: [{\n    product_id: {\n      type: mongoose.Schema.Types.ObjectId,\n      ref: 'Product',\n      required: true\n    },\n    quantity: {\n      type: Number,\n      required: true,\n      min: 1\n    },\n    price: {\n        type: Number,\n        required: true\n    }\n  }],\n  total_amount: {\n    type: Number,\n    default: 0\n  }\n}, { timestamps: true });\n\nmodule.exports = mongoose.model('Cart', cartSchema);",
        "backend/src/shopping_cart/controllers/cartController.js": "const Cart = require('../models/cart');\nconst Product = require('../../product/models/product');\n\nexports.getCart = async (req, res) => {\n  try {\n    const userId = req.user.id; // Assuming user ID is available in req.user\n    const cart = await Cart.findOne({ user_id: userId }).populate('items.product_id');\n\n    if (!cart) {\n      return res.status(404).json({ message: 'Cart not found' });\n    }\n\n    res.status(200).json(cart);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Server error', error: error.message });\n  }\n};\n\nexports.addItemToCart = async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { product_id, quantity } = req.body;\n\n    const product = await Product.findById(product_id);\n    if (!product) {\n      return res.status(404).json({ message: 'Product not found' });\n    }\n\n    let cart = await Cart.findOne({ user_id: userId });\n\n    if (!cart) {\n      cart = new Cart({ user_id: userId, items: [], total_amount: 0 });\n    }\n\n    const existingItemIndex = cart.items.findIndex(item => item.product_id.toString() === product_id);\n\n    if (existingItemIndex > -1) {\n      cart.items[existingItemIndex].quantity += quantity;\n    } else {\n      cart.items.push({ product_id: product_id, quantity: quantity, price: product.price });\n    }\n\n    cart.total_amount = cart.items.reduce((total, item) => total + (item.quantity * item.price), 0);\n\n    await cart.save();\n\n    res.status(201).json(cart);\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Server error', error: error.message });\n  }\n};\n\nexports.updateCartItem = async (req, res) => {\n    try {\n        const userId = req.user.id;\n        const { product_id, quantity } = req.body;\n\n        const cart = await Cart.findOne({ user_id: userId });\n\n        if (!cart) {\n            return res.status(404).json({ message: 'Cart not found' });\n        }\n\n        const itemIndex = cart.items.findIndex(item => item.product_id.toString() === product_id);\n\n        if (itemIndex === -1) {\n            return res.status(404).json({ message: 'Item not found in cart' });\n        }\n\n        cart.items[itemIndex].quantity = quantity;\n        cart.total_amount = cart.items.reduce((total, item) => total + (item.quantity * item.price), 0);\n\n        await cart.save();\n\n        res.status(200).json(cart);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ message: 'Server error', error: error.message });\n    }\n};\n\nexports.removeItemFromCart = async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { product_id } = req.params;\n\n    const cart = await Cart.findOne({ user_id: userId });\n\n    if (!cart) {\n      return res.status(404).json({ message: 'Cart not found' });\n    }\n\n    cart.items = cart.items.filter(item => item.product_id.toString() !== product_id);\n    cart.total_amount = cart.items.reduce((total, item) => total + (item.quantity * item.price), 0);\n\n    await cart.save();\n\n    res.status(200).json({ message: 'Item removed from cart', cart });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Server error', error: error.message });\n  }\n};\n\nexports.clearCart = async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const cart = await Cart.findOne({ user_id: userId });\n\n    if (!cart) {\n      return res.status(404).json({ message: 'Cart not found' });\n    }\n\n    cart.items = [];\n    cart.total_amount = 0;\n\n    await cart.save();\n\n    res.status(200).json({ message: 'Cart cleared', cart });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Server error', error: error.message });\n  }\n};",
        "backend/src/shopping_cart/routes/cartRoutes.js": "const express = require('express');\nconst router = express.Router();\nconst cartController = require('../controllers/cartController');\nconst { authenticateToken } = require('../../middleware/authMiddleware');\n\nrouter.get('/', authenticateToken, cartController.getCart);\nrouter.post('/items', authenticateToken, cartController.addItemToCart);\nrouter.put('/items', authenticateToken, cartController.updateCartItem);\nrouter.delete('/items/:product_id', authenticateToken, cartController.removeItemFromCart);\nrouter.delete('/', authenticateToken, cartController.clearCart);\n\nmodule.exports = router;",
        "frontend/src/components/ShoppingCart/ShoppingCart.js": "import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst ShoppingCart = () => {\n  const [cart, setCart] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchCart = async () => {\n      try {\n        const token = localStorage.getItem('token'); // Assuming token is stored in localStorage\n        const response = await axios.get('/api/shopping_cart', {\n          headers: { Authorization: `Bearer ${token}` },\n        });\n        setCart(response.data);\n      } catch (err) {\n        setError(err.message || 'Failed to fetch cart');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchCart();\n  }, []);\n\n  if (loading) {\n    return <p>Loading cart...</p>;\n  }\n\n  if (error) {\n    return <p>Error: {error}</p>;\n  }\n\n  if (!cart) {\n    return <p>Cart is empty.</p>;\n  }\n\n  return (\n    <div>\n      <h2>Shopping Cart</h2>\n      <ul>\n        {cart.items.map((item) => (\n          <li key={item.product_id._id}>\n            {item.product_id.name} - Quantity: {item.quantity} - Price: {item.price}\n          </li>\n        ))}\n      </ul>\n      <p>Total: {cart.total_amount}</p>\n    </div>\n  );\n};\n\nexport default ShoppingCart;",
        "database/migrations/20250605140000-create-shopping-carts.js": "'use strict';\nmodule.exports = {\n  up: async (queryInterface, Sequelize) => {\n    await queryInterface.createTable('ShoppingCarts', {\n      id: {\n        allowNull: false,\n        autoIncrement: true,\n        primaryKey: true,\n        type: Sequelize.INTEGER\n      },\n      user_id: {\n        type: Sequelize.INTEGER,\n        allowNull: false,\n        references: {\n          model: 'Users',\n          key: 'id'\n        },\n        onUpdate: 'CASCADE',\n        onDelete: 'CASCADE'\n      },\n      createdAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      },\n      updatedAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      }\n    });\n  },\n  down: async (queryInterface, Sequelize) => {\n    await queryInterface.dropTable('ShoppingCarts');\n  }\n};\n",
        "database/migrations/20250605140001-create-cart-items.js": "'use strict';\nmodule.exports = {\n  up: async (queryInterface, Sequelize) => {\n    await queryInterface.createTable('CartItems', {\n      id: {\n        allowNull: false,\n        autoIncrement: true,\n        primaryKey: true,\n        type: Sequelize.INTEGER\n      },\n      cart_id: {\n        type: Sequelize.INTEGER,\n        allowNull: false,\n        references: {\n          model: 'ShoppingCarts',\n          key: 'id'\n        },\n        onUpdate: 'CASCADE',\n        onDelete: 'CASCADE'\n      },\n      product_id: {\n        type: Sequelize.INTEGER,\n        allowNull: false,\n        references: {\n          model: 'Products',\n          key: 'id'\n        },\n        onUpdate: 'CASCADE',\n        onDelete: 'CASCADE'\n      },\n      quantity: {\n        type: Sequelize.INTEGER,\n        allowNull: false,\n        defaultValue: 1\n      },\n      price: {\n        type: Sequelize.DECIMAL(10, 2),\n        allowNull: false\n      },\n      createdAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      },\n      updatedAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      }\n    });\n  },\n  down: async (queryInterface, Sequelize) => {\n    await queryInterface.dropTable('CartItems');\n  }\n};"
      }
    },
    "Admin Dashboard": {
      "modules": [
        "backend",
        "frontend",
        "database",
        "admin_dashboard"
      ],
      "file_structure": {
        "backend/": "API server files",
        "frontend/": "UI application files",
        "database/": "Schema and migration files",
        "admin_dashboard/": "Admin dashboard module files",
        "admin_dashboard/src/": "Admin dashboard source code",
        "admin_dashboard/src/components/": "React components for the admin dashboard",
        "admin_dashboard/src/pages/": "React pages for the admin dashboard",
        "admin_dashboard/src/api/": "API client for the admin dashboard",
        "admin_dashboard/public/": "Static assets for the admin dashboard"
      },
      "dependencies": [
        "react",
        "react-router-dom",
        "@mui/material",
        "@mui/icons-material",
        "axios",
        "jsonwebtoken"
      ],
      "code_files": {
        "admin_dashboard/package.json": "{\n  \"name\": \"admin-dashboard\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"@emotion/react\": \"^11.11.1\",\n    \"@emotion/styled\": \"^11.11.0\",\n    \"@mui/icons-material\": \"^5.14.3\",\n    \"@mui/material\": \"^5.14.3\",\n    \"@testing-library/jest-dom\": \"^5.16.5\",\n    \"@testing-library/react\": \"^13.4.0\",\n    \"@testing-library/user-event\": \"^13.5.0\",\n    \"axios\": \"^1.4.0\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-router-dom\": \"^6.14.2\",\n    \"react-scripts\": \"5.0.1\",\n    \"web-vitals\": \"^2.1.4\",\n    \"jsonwebtoken\": \"^9.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"eslintConfig\": {\n    \"extends\": [\"react-app\", \"react-app/jest\"]\n  },\n  \"browserslist\": {\n    \"production\": [\">0.2%\", \"not dead\", \"not op_mini all\"],\n    \"development\": [\"last 1 chrome version\", \"last 1 firefox version\", \"last 1 safari version\"]\n  },\n  \"devDependencies\": {\n    \"eslint\": \"^8.0.0\",\n    \"eslint-config-react-app\": \"^7.0.1\"\n  }\n}",
        "admin_dashboard/src/index.js": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { BrowserRouter } from 'react-router-dom';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();",
        "admin_dashboard/src/App.js": "import React from 'react';\nimport { Routes, Route } from 'react-router-dom';\nimport Dashboard from './pages/Dashboard';\nimport Products from './pages/Products';\nimport Orders from './pages/Orders';\nimport Users from './pages/Users';\nimport Login from './pages/Login';\nimport { AuthProvider } from './AuthContext';\nimport PrivateRoute from './PrivateRoute';\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <Routes>\n        <Route path=\"/login\" element={<Login />} />\n        <Route path=\"/\" element={<PrivateRoute><Dashboard /></PrivateRoute>} />\n        <Route path=\"/products\" element={<PrivateRoute><Products /></PrivateRoute>} />\n        <Route path=\"/orders\" element={<PrivateRoute><Orders /></PrivateRoute>} />\n        <Route path=\"/users\" element={<PrivateRoute><Users /></PrivateRoute>} />\n      </Routes>\n    </AuthProvider>\n  );\n}\n\nexport default App;",
        "admin_dashboard/src/AuthContext.js": "import React, { createContext, useState, useContext } from 'react';\n\nconst AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) => {\n  const [authTokens, setAuthTokens] = useState(localStorage.getItem('tokens') || null);\n\n  const setTokens = (data) => {\n    localStorage.setItem('tokens', JSON.stringify(data));\n    setAuthTokens(data);\n  };\n\n  return (\n    <AuthContext.Provider value={{ authTokens, setAuthTokens: setTokens }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => {\n  return useContext(AuthContext);\n};",
        "admin_dashboard/src/PrivateRoute.js": "import React from 'react';\nimport { Route, Navigate } from 'react-router-dom';\nimport { useAuth } from './AuthContext';\n\nfunction PrivateRoute({ children }) {\n  const { authTokens } = useAuth();\n\n  return authTokens ? children : <Navigate to=\"/login\" />;\n}\n\nexport default PrivateRoute;",
        "admin_dashboard/src/pages/Dashboard.js": "import React from 'react';\nimport { Typography, Container } from '@mui/material';\n\nfunction Dashboard() {\n  return (\n    <Container>\n      <Typography variant=\"h4\" component=\"h1\" gutterBottom>\n        Admin Dashboard\n      </Typography>\n      <Typography variant=\"body1\">\n        Welcome to the admin dashboard. You can manage products, orders, and users here.\n      </Typography>\n    </Container>\n  );\n}\n\nexport default Dashboard;",
        "admin_dashboard/src/pages/Products.js": "import React from 'react';\nimport { Typography, Container } from '@mui/material';\n\nfunction Products() {\n  return (\n    <Container>\n      <Typography variant=\"h4\" component=\"h1\" gutterBottom>\n        Products\n      </Typography>\n      <Typography variant=\"body1\">\n        Manage your products here.\n      </Typography>\n    </Container>\n  );\n}\n\nexport default Products;",
        "admin_dashboard/src/pages/Orders.js": "import React from 'react';\nimport { Typography, Container } from '@mui/material';\n\nfunction Orders() {\n  return (\n    <Container>\n      <Typography variant=\"h4\" component=\"h1\" gutterBottom>\n        Orders\n      </Typography>\n      <Typography variant=\"body1\">\n        Manage your orders here.\n      </Typography>\n    </Container>\n  );\n}\n\nexport default Orders;",
        "admin_dashboard/src/pages/Users.js": "import React from 'react';\nimport { Typography, Container } from '@mui/material';\n\nfunction Users() {\n  return (\n    <Container>\n      <Typography variant=\"h4\" component=\"h1\" gutterBottom>\n        Users\n      </Typography>\n      <Typography variant=\"body1\">\n        Manage your users here.\n      </Typography>\n    </Container>\n  );\n}\n\nexport default Users;",
        "admin_dashboard/src/pages/Login.js": "import React, { useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { TextField, Button, Container, Typography, Box } from '@mui/material';\nimport axios from 'axios';\nimport { useAuth } from '../AuthContext';\n\nfunction Login() {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n  const { setAuthTokens } = useAuth();\n\n  const handleSubmit = async (event) => {\n    event.preventDefault();\n    try {\n      const response = await axios.post('/api/admin/login', {\n        username: username,\n        password: password,\n      });\n\n      if (response.status === 200) {\n        setAuthTokens(response.data.tokens);\n        navigate('/');\n      } else {\n        alert('Invalid credentials');\n      }\n    } catch (error) {\n      console.error('Login error:', error);\n      alert('Invalid credentials');\n    }\n  };\n\n  return (\n    <Container component=\"main\" maxWidth=\"xs\">\n      <Box\n        sx={{\n          marginTop: 8,\n          display: 'flex',\n          flexDirection: 'column',\n          alignItems: 'center',\n        }}\n      >\n        <Typography component=\"h1\" variant=\"h5\">\n          Admin Login\n        </Typography>\n        <Box component=\"form\" onSubmit={handleSubmit} noValidate sx={{ mt: 1 }}>\n          <TextField\n            margin=\"normal\"\n            required\n            fullWidth\n            id=\"username\"\n            label=\"Username\"\n            name=\"username\"\n            autoComplete=\"username\"\n            autoFocus\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n          />\n          <TextField\n            margin=\"normal\"\n            required\n            fullWidth\n            name=\"password\"\n            label=\"Password\"\n            type=\"password\"\n            id=\"password\"\n            autoComplete=\"current-password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n          />\n          <Button\n            type=\"submit\"\n            fullWidth\n            variant=\"contained\"\n            sx={{ mt: 3, mb: 2 }}\n          >\n            Sign In\n          </Button>\n        </Box>\n      </Box>\n    </Container>\n  );\n}\n\nexport default Login;"
      }
    }
  },
  "file_structure": {},
  "dependencies": [
    "dotenv",
    "@mui/icons-material",
    "cors",
    "vnpay",
    "react",
    "morgan",
    "sequelize",
    "pg",
    "passport",
    "axios",
    "bcryptjs",
    "pg-hstore",
    "bcrypt",
    "react-router-dom",
    "passport-jwt",
    "momo-payment",
    "express",
    "mongoose",
    "express-validator",
    "@mui/material",
    "jsonwebtoken"
  ],
  "status": "completed"
}